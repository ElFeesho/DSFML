<html><head>
       <META http-equiv="content-type" content="text/html; charset=utf-8">
       <link rel="stylesheet" type="text/css" media="screen" href="../../stylesheets/stylesheet.css">
       <link rel="stylesheet" type="text/css" media="screen" href="../../stylesheets/dsfml.css">
       <title>dsfml.graphics.rendertexture</title>
       </head><body>
       <div id="header_wrap" class="outer">
        <header class="inner">
        	<a id="forkme_banner" href="https://github.com/Jebbs/DSFML">View on GitHub</a>
        	<h1 id="project_title">DSFML</h1>

			<ul class="hnav">
  				<li class="hnav"><a class="hnav" href="../../index.html">Home</a></li>
           		<li class="hnav"><a class="hnav" href="../../tutorials.html">Tutorials</a></li>
  				<li class="hnav"><a class="hnav" href="../../doc.html">Documentation</a></li>
  				<li class="hnav"><a class="hnav" href="../../downloads.html">Downloads</a></li>
  				<li class="hnav"><a class="hnav" href="http://en.sfml-dev.org/forums/index.php?board=13.0">Forum</a></li>
           		<li class="hnav"><a class="hnav" href="../../contact.html">Contact</a></li>
				</ul>
        </header>
    	</div>

    	<div id="main_content_wrap" class="outer">

    	<div class="nav">
	 <ul>
		<dl class="nav">
		<dt class="nav"><li>System</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/clock.html">Clock</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/err.html">Err</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/inputstream.html">InputStream</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/lock.html">Lock</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/mutex.html">Mutex</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/sleep.html">Sleep</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/string.html">String</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/thread.html">Thread</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/time.html">Time</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/vector2.html">Vector2</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/vector3.html">Vector3</a></li></dd>
        <dt class="nav"><li>Window</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/context.html">Context</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/contextsettings.html">ContextSettings</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/event.html">Event</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/joystick.html">Joystick</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/keyboard.html">Keyboard</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/mouse.html">Mouse</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/videomode.html">VideoMode</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/window.html">Window</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/windowhandle.html">WindowHandle</a></li></dd>
		<dt class="nav"><li>Graphics</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/blendmode.html">BlendMode</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/circleshape.html">CircleShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/color.html">Color</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/convexshape.html">ConvexShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/drawable.html">Drawable</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/font.html">Font</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/glyph.html">Glyph</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/image.html">Image</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/primitivetype.html">PrimitiveType</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rect.html">Rect</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rectangleshape.html">RectangleShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/renderstates.html">RenderStates</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rendertarget.html">RenderTarget</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rendertexture.html">RenderTexture</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/renderwindow.html">RenderWindow</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/shader.html">Shader</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/shape.html">Shape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/sprite.html">Sprite</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/text.html">Text</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/texture.html">Texture</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/transform.html">Transform</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/transformable.html">Transformable</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/vertex.html">Vertex</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/vertexarray.html">VertexArray</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/view.html">View</a></li></dd>
		<dt class="nav"><li>Audio</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/audio/listener.html">Listener</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/music.html">Music</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/sound.html">Sound</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundbuffer.html">SoundBuffer</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundbufferrecorder.html">SoundBufferRecorder</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundrecorder.html">SoundRecorder</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundsource.html">SounSource</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundstream.html">SoundStream</a></li></dd>
        <dt class="nav"><li>Network</li></dt>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/ftp.html">Ftp</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/http.html">Http</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/ipaddress.html">IpAddress</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/packet.html">Packet</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/socket.html">Socket</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/socketselector.html">SocketSelector</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/tcplistener.html">TcpListener</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/tcpsocket.html">TcpSocket</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/udpsocket.html">UdpSocket</a></li></dd>
		</dl>
    </ul>
	</div>

    	<section  style="min-height: 1700px;" id="main_content" class="inner">
       <h1>dsfml.graphics.rendertexture</h1>
       <!-- Generated by Ddoc from dsfml\graphics\rendertexture.d -->
<br><br>
<dl><dt><big><a name="RenderTexture"></a>class <u>RenderTexture</u>: <u>dsfml.graphics.rendertarget.RenderTarget</u>;
</big></dt>
<dd>Target for off-screen 2D rendering into a texture.
<br><br>
 <u>RenderTexture</u> is the little brother of RenderWindow.
<br><br>

 It implements the same 2D drawing and OpenGL-related functions (see their base class RenderTarget for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window.
<br><br>

 Rendering to a texture can be useful in a variety of situations:
 - precomputing a complex static texture (like a level's background from multiple tiles)
 - applying post-effects to the whole scene with shaders
 - creating a sprite from a 3D object rendered with OpenGL
 - etc.

<br><br>
<b>Authors:</b><br>
Laurent Gomila, Jeremy DeHaan
<br><br>
<b>See Also:</b><br>
<br><br>
<b>http:</b><br>
//www.sfml-dev.org/documentation/2.0/classsf_1_1RenderTexture.php#details<br><br>

<dl><dt><big><a name="RenderTexture.create"></a>void <u>create</u>(uint <i>width</i>, uint <i>height</i>, bool <i>depthBuffer</i> = false);
</big></dt>
<dd>Create the render-texture.
<br><br>
Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture.
<br><br>

 The last parameter, <i>depthBuffer</i>, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth-buffer. Otherwise it is unnecessary, and you should leave this parameter to <b>false</b> (which is its default value).

<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>width</i></td>
<td>Width of the render-texture</td></tr>
<tr><td>uint <i>height</i></td>
<td>Height of the render-texture</td></tr>
<tr><td>bool <i>depthBuffer</i></td>
<td>Do you want this render-texture to have a depth buffer?</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.smooth"></a>@property bool <u>smooth</u>(bool <i>newSmooth</i>);
</big></dt>
<dd>Enable or disable texture smoothing.<br><br>

</dd>
<dt><big><a name="RenderTexture.smooth.2"></a>@property bool <u>smooth</u>();
</big></dt>
<dd>Enable or disable texture smoothing.<br><br>

</dd>
<dt><big><a name="RenderTexture.view"></a>@property const(View) <u>view</u>(const(View) <i>newView</i>);
</big></dt>
<dd>Change the current active <u>view</u>.
<br><br>
The <u>view</u> is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render-target. The new <u>view</u> will affect everything that is drawn, until another <u>view</u> is set.
<br><br>

 The render target keeps its own copy of the <u>view</u> object, so it is not necessary to keep the original one alive after calling this function. To restore the original <u>view</u> of the target, you can pass the result of getDefaultView() to this function.<br><br>

</dd>
<dt><big><a name="RenderTexture.view.2"></a>const @property const(View) <u>view</u>();
</big></dt>
<dd>Change the current active <u>view</u>.
<br><br>
The <u>view</u> is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render-target. The new <u>view</u> will affect everything that is drawn, until another <u>view</u> is set.
<br><br>

 The render target keeps its own copy of the <u>view</u> object, so it is not necessary to keep the original one alive after calling this function. To restore the original <u>view</u> of the target, you can pass the result of getDefaultView() to this function.<br><br>

</dd>
<dt><big><a name="RenderTexture.getDefaultView"></a>const const(View) <u>getDefaultView</u>();
</big></dt>
<dd>Get the default view of the render target.
<br><br>
The default view has the initial size of the render target, and never changes after the target has been created.

<br><br>
<b>Returns:</b><br>
The default view of the render target.<br><br>

</dd>
<dt><big><a name="RenderTexture.getSize"></a>const Vector2u <u>getSize</u>();
</big></dt>
<dd>Return the size of the rendering region of the target.
<br><br>
<b>Returns:</b><br>
Size in pixels<br><br>

</dd>
<dt><big><a name="RenderTexture.getViewport"></a>const IntRect <u>getViewport</u>(const(View) <i>view</i>);
</big></dt>
<dd>Get the viewport of a <i>view</i>, applied to this render target.
<br><br>
The viewport is defined in the <i>view</i> as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target.

<br><br>
<b>Params:</b><br>
<table><tr><td>const(View) <i>view</i></td>
<td>The <i>view</i> for which we want to compute the viewport</td></tr>
</table><br>
<b>Returns:</b><br>
Viewport rectangle, expressed in pixels<br><br>

</dd>
<dt><big><a name="RenderTexture.getTexture"></a>const(Texture) <u>getTexture</u>();
</big></dt>
<dd>Get a read-only reference to the target texture.
<br><br>
After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example).
<br><br>

 The internal Texture of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified.

<br><br>
<b>Returns:</b><br>
Const reference to the texture.<br><br>

</dd>
<dt><big><a name="RenderTexture.setActive"></a>void <u>setActive</u>(bool <i>active</i> = true);
</big></dt>
<dd>Activate or deactivate the render-texture for rendering.
<br><br>
This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff).
<br><br>

 Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a RenderWindow) don't forget to activate it again.

<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>active</i></td>
<td>True to activate, <b>false</b> to deactivate</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.clear"></a>void <u>clear</u>(Color <i>color</i> = Color.Black);
</big></dt>
<dd>Clear the entire target with a single <i>color</i>.
<br><br>
This function is usually called once every frame, to <u>clear</u> the previous contents of the target.

<br><br>
<b>Params:</b><br>
<table><tr><td>Color <i>color</i></td>
<td>Fill <i>color</i> to use to <u>clear</u> the render target</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.display"></a>void <u>display</u>();
</big></dt>
<dd>Update the contents of the target texture.
<br><br>
This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state.<br><br>

</dd>
<dt><big><a name="RenderTexture.draw"></a>void <u>draw</u>(Drawable <i>drawable</i>, RenderStates <i>states</i> = RenderStates.Default);
</big></dt>
<dd>Draw a <i>drawable</i> object to the render target.
<br><br>
<b>Params:</b><br>
<table><tr><td>Drawable <i>drawable</i></td>
<td>Object to <u>draw</u></td></tr>
<tr><td>RenderStates <i>states</i></td>
<td>Render <i>states</i> to use for drawing</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.draw.2"></a>void <u>draw</u>(const(Vertex)[] <i>vertices</i>, PrimitiveType <i>type</i>, RenderStates <i>states</i> = RenderStates.Default);
</big></dt>
<dd>Draw primitives defined by an array of <i>vertices</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(Vertex)[] <i>vertices</i></td>
<td>Array of <i>vertices</i> to <u>draw</u></td></tr>
<tr><td>PrimitiveType <i>type</i></td>
<td>Type of primitives to <u>draw</u></td></tr>
<tr><td>RenderStates <i>states</i></td>
<td>Render <i>states</i> to use for drawing</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.mapPixelToCoords"></a>const Vector2f <u>mapPixelToCoords</u>(Vector2i <i>point</i>);
</big></dt>
<dd>Convert a <i>point</i> fom target coordinates to world coordinates, using the current view.
<br><br>
This function is an overload of the <u>mapPixelToCoords</u> function that implicitely uses the current view.

<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2i <i>point</i></td>
<td>Pixel to convert</td></tr>
</table><br>
<b>Returns:</b><br>
The converted <i>point</i>, in "world" coordinates.<br><br>

</dd>
<dt><big><a name="RenderTexture.mapPixelToCoords.2"></a>const Vector2f <u>mapPixelToCoords</u>(Vector2i <i>point</i>, const(View) <i>view</i>);
</big></dt>
<dd>Convert a <i>point</i> from target coordinates to world coordinates.
<br><br>
This function finds the 2D position that matches the given pixel of the render-target. In other words, it does the inverse of what the graphics card does, to find the initial position of a rendered pixel.
<br><br>

 Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom <i>view</i> or resize your render-target, this assertion is not <b>true</b> anymore, ie. a <i>point</i> located at (10, 50) in your render-target may map to the <i>point</i> (150, 75) in your 2D world – if the <i>view</i> is translated by (140, 25).
<br><br>

 For render-windows, this function is typically used to find which <i>point</i> (or object) is located below the mouse cursor.
<br><br>

 This version uses a custom <i>view</i> for calculations, see the other overload of the function if you want to use the current <i>view</i> of the render-target.

<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2i <i>point</i></td>
<td>Pixel to convert</td></tr>
<tr><td>const(View) <i>view</i></td>
<td>The <i>view</i> to use for converting the <i>point</i></td></tr>
</table><br>
<b>Returns:</b><br>
The converted <i>point</i>, in "world" coordinates.<br><br>

</dd>
<dt><big><a name="RenderTexture.mapCoordsToPixel"></a>const Vector2i <u>mapCoordsToPixel</u>(Vector2f <i>point</i>);
</big></dt>
<dd>Convert a <i>point</i> from target coordinates to world coordinates, using the current view.
<br><br>
This function is an overload of the mapPixelToCoords function that implicitely uses the current view.

<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2f <i>point</i></td>
<td>Point to convert
<br><br>

 The converted <i>point</i>, in "world" coordinates</td></tr>
</table><br>

</dd>
<dt><big><a name="RenderTexture.mapCoordsToPixel.2"></a>const Vector2i <u>mapCoordsToPixel</u>(Vector2f <i>point</i>, const(View) <i>view</i>);
</big></dt>
<dd>Convert a <i>point</i> from world coordinates to target coordinates.
<br><br>
This function finds the pixel of the render-target that matches the given 2D <i>point</i>. In other words, it goes through the same process as the graphics card, to compute the final position of a rendered <i>point</i>.
<br><br>

 Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom <i>view</i> or resize your render-target, this assertion is not <b>true</b> anymore, ie. a <i>point</i> located at (150, 75) in your 2D world may map to the pixel (10, 50) of your render-target – if the <i>view</i> is translated by (140, 25).
<br><br>

 This version uses a custom <i>view</i> for calculations, see the other overload of the function if you want to use the current <i>view</i> of the render-target.

<br><br>
<b>Params:</b><br>
<table><tr><td>Vector2f <i>point</i></td>
<td>Point to convert</td></tr>
<tr><td>const(View) <i>view</i></td>
<td>The <i>view</i> to use for converting the <i>point</i></td></tr>
</table><br>
<b>Returns:</b><br>
The converted <i>point</i>, in target coordinates (pixels)<br><br>

</dd>
<dt><big><a name="RenderTexture.popGLStates"></a>void <u>popGLStates</u>();
</big></dt>
<dd>Restore the previously saved OpenGL render states and matrices.
<br><br>
See the description of pushGLStates to get a detailed description of these functions.<br><br>

</dd>
<dt><big><a name="RenderTexture.pushGLStates"></a>void <u>pushGLStates</u>();
</big></dt>
<dd>Save the current OpenGL render states and matrices.
<br><br>
 This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with PopGLStates, it ensures that:
 - SFML's internal states are not messed up by your OpenGL code
 - your OpenGL states are not modified by a call to an SFML function
<br><br>

 More specifically, it must be used around the code that calls Draw functions.
<br><br>

 Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the ResetGLStates function if you do so.<br><br>

</dd>
<dt><big><a name="RenderTexture.resetGLStates"></a>void <u>resetGLStates</u>();
</big></dt>
<dd>Reset the internal OpenGL states so that the target is ready for drawing.
<br><br>
This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use pushGLStates/popGLStates. It makes sure that all OpenGL states needed by SFML are set, so that subsequent draw() calls will work as expected.<br><br>

</dd>
</dl>
</dd>
</dl>

       </section>
    </div>
       </body></html>
