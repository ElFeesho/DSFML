<html><head>
       <META http-equiv="content-type" content="text/html; charset=utf-8">
       <link rel="stylesheet" type="text/css" media="screen" href="../../stylesheets/stylesheet.css">
       <link rel="stylesheet" type="text/css" media="screen" href="../../stylesheets/dsfml.css">
       <title>dsfml.graphics.shader</title>
       </head><body>
       <div id="header_wrap" class="outer">
        <header class="inner">
        	<a id="forkme_banner" href="https://github.com/Jebbs/DSFML">View on GitHub</a>
        	<h1 id="project_title">DSFML</h1>

			<ul class="hnav">
  				<li class="hnav"><a class="hnav" href="../../index.html">Home</a></li>
           		<li class="hnav"><a class="hnav" href="../../tutorials.html">Tutorials</a></li>
  				<li class="hnav"><a class="hnav" href="../../doc.html">Documentation</a></li>
  				<li class="hnav"><a class="hnav" href="../../downloads.html">Downloads</a></li>
  				<li class="hnav"><a class="hnav" href="http://en.sfml-dev.org/forums/index.php?board=13.0">Forum</a></li>
           		<li class="hnav"><a class="hnav" href="../../contact.html">Contact</a></li>
				</ul>
        </header>
    	</div>

    	<div id="main_content_wrap" class="outer">

    	<div class="nav">
	 <ul>
		<dl class="nav">
		<dt class="nav"><li>System</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/clock.html">Clock</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/err.html">Err</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/inputstream.html">InputStream</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/lock.html">Lock</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/mutex.html">Mutex</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/system/sleep.html">Sleep</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/string.html">String</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/thread.html">Thread</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/time.html">Time</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/vector2.html">Vector2</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/system/vector3.html">Vector3</a></li></dd>
        <dt class="nav"><li>Window</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/context.html">Context</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/contextsettings.html">ContextSettings</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/event.html">Event</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/joystick.html">Joystick</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/keyboard.html">Keyboard</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/window/mouse.html">Mouse</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/videomode.html">VideoMode</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/window.html">Window</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/window/windowhandle.html">WindowHandle</a></li></dd>
		<dt class="nav"><li>Graphics</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/blendmode.html">BlendMode</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/circleshape.html">CircleShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/color.html">Color</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/convexshape.html">ConvexShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/drawable.html">Drawable</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/font.html">Font</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/glyph.html">Glyph</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/image.html">Image</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/primitivetype.html">PrimitiveType</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rect.html">Rect</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rectangleshape.html">RectangleShape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/renderstates.html">RenderStates</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rendertarget.html">RenderTarget</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/rendertexture.html">RenderTexture</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/renderwindow.html">RenderWindow</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/shader.html">Shader</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/shape.html">Shape</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/sprite.html">Sprite</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/text.html">Text</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/texture.html">Texture</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/transform.html">Transform</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/transformable.html">Transformable</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/vertex.html">Vertex</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/vertexarray.html">VertexArray</a></li></dd>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/graphics/view.html">View</a></li></dd>
		<dt class="nav"><li>Audio</li></dt>
			<dd class="nav"><li><a class="hnav" href="../../dsfml/audio/listener.html">Listener</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/music.html">Music</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/sound.html">Sound</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundbuffer.html">SoundBuffer</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundbufferrecorder.html">SoundBufferRecorder</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundrecorder.html">SoundRecorder</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundsource.html">SounSource</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/audio/soundstream.html">SoundStream</a></li></dd>
        <dt class="nav"><li>Network</li></dt>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/ftp.html">Ftp</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/http.html">Http</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/ipaddress.html">IpAddress</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/packet.html">Packet</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/socket.html">Socket</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/socketselector.html">SocketSelector</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/tcplistener.html">TcpListener</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/tcpsocket.html">TcpSocket</a></li></dd>
            <dd class="nav"><li><a class="hnav" href="../../dsfml/network/udpsocket.html">UdpSocket</a></li></dd>
		</dl>
    </ul>
	</div>

    	<section  style="min-height: 1700px;" id="main_content" class="inner">
       <h1>dsfml.graphics.shader</h1>
       <!-- Generated by Ddoc from dsfml\graphics\shader.d -->
<br><br>
<dl><dt><big><a name="Shader"></a>class <u>Shader</u>;
</big></dt>
<dd><u>Shader</u> class (vertex and fragment).
<br><br>
 Shaders are programs written using a specific language, executed directly by the graphics card and allowing one to apply real-time operations to the rendered entities.
<br><br>

 There are two kinds of shaders:
 - Vertex shaders, that process vertices
 - Fragment (pixel) shaders, that process pixels
<br><br>

 A DSFML <u>Shader</u> can be composed of either a vertex shader alone, a fragment shader alone, or both combined (see the variants of the load functions).
<br><br>

 Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for SFML.
<br><br>

 Like any D/C/C++ program, a shader has its own variables that you can set from your D application. DSFML's <u>Shader</u> handles 5 different types of variables:
 - floats
 - vectors (2, 3, or 4 components)
 - colors
 - textures
 - transforms (matrices)

<br><br>
<b>Authors:</b><br>
Laurent Gomila, Jeremy DeHaan
<br><br>
<b>See Also:</b><br>
<br><br>
<b>http:</b><br>
//www.sfml-dev.org/documentation/2.0/classsf_1_1Shader.php#details<br><br>

<dl><dt><big><a name="Shader.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>Types of shaders.<br><br>

<dl><dt><big><a name="Shader.Type.Vertex"></a><u>Vertex</u></big></dt>
<dd><u>Vertex</u> shader<br><br>

</dd>
<dt><big><a name="Shader.Type.Fragment"></a><u>Fragment</u></big></dt>
<dd><u>Fragment</u> (pixel) shader.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shader.CurrentTextureType"></a>struct <u>CurrentTextureType</u>;
</big></dt>
<dd>Special type/value that can be passed to setParameter, and that represents the texture of the object being drawn.<br><br>

</dd>
<dt><big><a name="Shader.loadFromFile"></a>bool <u>loadFromFile</u>(string <i>filename</i>, Type <i>type</i>);
</big></dt>
<dd>Load either the vertex or fragment shader from a file.
<br><br>
This function loads a single shader, either vertex or fragment, identified by the second argument. The source must be a text file containing a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>filename</i></td>
<td>Path of the vertex or fragment shader file to load</td></tr>
<tr><td>Type <i>type</i></td>
<td>Type of shader (vertex or fragment)</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.loadFromFile.2"></a>bool <u>loadFromFile</u>(string <i>vertexShaderFilename</i>, string <i>fragmentShaderFilename</i>);
</big></dt>
<dd>Load both the vertex and fragment shaders from files.
<br><br>
This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>vertexShaderFilename</i></td>
<td>Path of the vertex shader file to load</td></tr>
<tr><td>string <i>fragmentShaderFilename</i></td>
<td>Path of the fragment shader file to load</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.loadFromMemory"></a>bool <u>loadFromMemory</u>(string <i>shader</i>, Type <i>type</i>);
</big></dt>
<dd>Load either the vertex or fragment <i>shader</i> from a source code in memory.
<br><br>
This function loads a single <i>shader</i>, either vertex or fragment, identified by the second argument. The source code must be a valid <i>shader</i> in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>shader</i></td>
<td>String containing the source code of the <i>shader</i></td></tr>
<tr><td>Type <i>type</i></td>
<td>Type of <i>shader</i> (vertex or fragment)</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.loadFromMemory.2"></a>bool <u>loadFromMemory</u>(string <i>vertexShader</i>, string <i>fragmentShader</i>);
</big></dt>
<dd>Load both the vertex and fragment shaders from source codes in memory.
<br><br>
This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>vertexShader</i></td>
<td>String containing the source code of the vertex shader</td></tr>
<tr><td>string <i>fragmentShader</i></td>
<td>String containing the source code of the fragment shader</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.loadFromStream"></a>bool <u>loadFromStream</u>(InputStream <i>stream</i>, Type <i>type</i>);
</big></dt>
<dd>Load either the vertex or fragment shader from a custom <i>stream</i>.
<br><br>
This function loads a single shader, either vertex or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>InputStream <i>stream</i></td>
<td>Source <i>stream</i> to read from</td></tr>
<tr><td>Type <i>type</i></td>
<td>Type of shader (vertex or fragment)</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.loadFromStream.2"></a>bool <u>loadFromStream</u>(InputStream <i>vertexShaderStream</i>, InputStream <i>fragmentShaderStream</i>);
</big></dt>
<dd>Load both the vertex and fragment shaders from custom streams.
<br><br>
This function loads a single shader, either vertex or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.

<br><br>
<b>Params:</b><br>
<table><tr><td>InputStream <i>vertexShaderStream</i></td>
<td>Source stream to read the vertex shader from</td></tr>
<tr><td>InputStream <i>fragmentShaderStream</i></td>
<td>Source stream to read the fragment shader from</td></tr>
</table><br>
<b>Returns:</b><br>
True if loading succeeded, <b>false</b> if it failed.<br><br>

</dd>
<dt><big><a name="Shader.setParameter"></a>void <u>setParameter</u>(string <i>name</i>, float <i>x</i>);
<br><a name="Shader.opIndexAssign"></a>void <u>opIndexAssign</u>(float <i>x</i>, string <i>name</i>);
</big></dt>
<dd>Change a float parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a float (float GLSL type).</td></tr>
<tr><td>float <i>x</i></td>
<td>Value to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.2"></a>void <u>setParameter</u>(string <i>name</i>, float <i>x</i>, float <i>y</i>);
</big></dt>
<dd>Change a 2-components vector parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 vector (vec2 GLSL type).</td></tr>
<tr><td>float <i>x</i></td>
<td>First component of the value to assign</td></tr>
<tr><td>float <i>y</i></td>
<td>Second component of the value to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.3"></a>void <u>setParameter</u>(string <i>name</i>, float <i>x</i>, float <i>y</i>, float <i>z</i>);
</big></dt>
<dd>Change a 3-components vector parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 3x1 vector (vec3 GLSL type).</td></tr>
<tr><td>float <i>x</i></td>
<td>First component of the value to assign</td></tr>
<tr><td>float <i>y</i></td>
<td>Second component of the value to assign</td></tr>
<tr><td>float <i>z</i></td>
<td>Third component of the value to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.4"></a>void <u>setParameter</u>(string <i>name</i>, float <i>x</i>, float <i>y</i>, float <i>z</i>, float <i>w</i>);
</big></dt>
<dd>Change a 4-components vector parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).</td></tr>
<tr><td>float <i>x</i></td>
<td>First component of the value to assign</td></tr>
<tr><td>float <i>y</i></td>
<td>Second component of the value to assign</td></tr>
<tr><td>float <i>z</i></td>
<td>Third component of the value to assign</td></tr>
<tr><td>float <i>w</i></td>
<td>Fourth component of the value to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.opIndexAssign.2"></a>void <u>opIndexAssign</u>(float[] <i>val</i>, string <i>name</i>);
</big></dt>
<dd>Change variable length vector parameter of the shader. The length of the set of floats must be between 1 and 4.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).</td></tr>
<tr><td>float[] <i>val</i></td>
<td>The set of floats to assign.</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.5"></a>void <u>setParameter</u>(string <i>name</i>, Vector2f <i>vector</i>);
<br><a name="Shader.opIndexAssign.3"></a>void <u>opIndexAssign</u>(Vector2f <i>vector</i>, string <i>name</i>);
</big></dt>
<dd>Change a 2-components <i>vector</i> parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 2x1 <i>vector</i> (vec2 GLSL type).</td></tr>
<tr><td>Vector2f <i>vector</i></td>
<td>Vector to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.6"></a>void <u>setParameter</u>(string <i>name</i>, Vector3f <i>vector</i>);
<br><a name="Shader.opIndexAssign.4"></a>void <u>opIndexAssign</u>(Vector3f <i>vector</i>, string <i>name</i>);
</big></dt>
<dd>Change a 3-components <i>vector</i> parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 3x1 <i>vector</i> (vec3 GLSL type).</td></tr>
<tr><td>Vector3f <i>vector</i></td>
<td>Vector to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.7"></a>void <u>setParameter</u>(string <i>name</i>, Color <i>color</i>);
<br><a name="Shader.opIndexAssign.5"></a>void <u>opIndexAssign</u>(Color <i>color</i>, string <i>name</i>);
</big></dt>
<dd>Change a <i>color</i> vector parameter of the shader.
<br><br>
It is important to note that the components of the <i>color</i> are normalized before being passed to the shader. Therefore, they are converted from range [0 .. 255] to range [0 .. 1]. For example, a Color(255, 125, 0, 255) will be transformed to a vec4(1.0, 0.5, 0.0, 1.0) in the shader.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 4x1 vector (vec4 GLSL type).</td></tr>
<tr><td>Color <i>color</i></td>
<td>Color to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.8"></a>void <u>setParameter</u>(string <i>name</i>, Transform <i>transform</i>);
<br><a name="Shader.opIndexAssign.6"></a>void <u>opIndexAssign</u>(Transform <i>transform</i>, string <i>name</i>);
</big></dt>
<dd>Change a matrix parameter of the shader.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 4x4 matrix (mat4 GLSL type).</td></tr>
<tr><td>Transform <i>transform</i></td>
<td>Transform to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.9"></a>void <u>setParameter</u>(string <i>name</i>, Texture <i>texture</i>);
<br><a name="Shader.opIndexAssign.7"></a>void <u>opIndexAssign</u>(Texture <i>texture</i>, string <i>name</i>);
</big></dt>
<dd>Change a <i>texture</i> parameter of the shader.
<br><br>
It is important to note that the <i>texture</i> parameter must remain alive as long as the shader uses it - no copoy is made internally.
<br><br>

 To use the <i>texture</i> of the object being draw, which cannot be known in advance, you can pass the special value Shader.CurrentTexture.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 2D <i>texture</i> (sampler2D GLSL type).</td></tr>
<tr><td>Texture <i>texture</i></td>
<td>Texture to assign</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.setParameter.10"></a>void <u>setParameter</u>(string <i>name</i>, CurrentTextureType);
</big></dt>
<dd>Change a texture parameter of the shader.
<br><br>
This overload maps a shader texture variable to the texture of the object being drawn, which cannot be known in advance. The second argument must be Shader.CurrentTexture.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 2D texture (sampler2D GLSL type).</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.opIndexAssign.8"></a>void <u>opIndexAssign</u>(CurrentTextureType, string <i>name</i>);
</big></dt>
<dd>Change a texture parameter of the shader.
<br><br>
This overload maps a shader texture variable to the texture of the object being drawn, which cannot be known in advance. The value given must be Shader.CurrentTexture.

<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the variable to change in the shader. The corresponding parameter in the shader must be a 2D texture (sampler2D GLSL type).</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.bind"></a>static void <u>bind</u>(Shader <i>shader</i>);
</big></dt>
<dd>Bind a <i>shader</i> for rendering.
<br><br>
This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix Shader with OpenGL code.

<br><br>
<b>Params:</b><br>
<table><tr><td>Shader <i>shader</i></td>
<td>Shader to <u>bind</u>. Can be <b>null</b> to use no <i>shader</i>.</td></tr>
</table><br>

</dd>
<dt><big><a name="Shader.isAvailable"></a>static bool <u>isAvailable</u>();
</big></dt>
<dd>Tell whether or not the system supports shaders.
<br><br>
This function should always be called before using the shader features. If it returns <b>false</b>, then any attempt to use DSFML Shader will fail.

<br><br>
<b>Returns:</b><br>
True if shaders are supported, <b>false</b> otherwise<br><br>

</dd>
</dl>
</dd>
</dl>

       </section>
    </div>
       </body></html>
